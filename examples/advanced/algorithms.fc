// Advanced Example: Common Algorithms
//
// Demonstrates algorithm patterns in FastC.
// Since array literals aren't available, these show the function signatures
// and logic patterns.

// Binary search in a sorted slice
// Returns index of element, or -1 if not found
fn binary_search(s: slice(i32), target: i32, low: i32, high: i32) -> i32 {
    if (low > high) {
        return -1;  // Not found
    }

    let mid: i32 = (low + ((high - low) / 2));
    let mid_val: i32 = at(s, cast(usize, mid));

    if (mid_val == target) {
        return mid;
    } else if (mid_val > target) {
        return binary_search(s, target, low, (mid - 1));
    } else {
        return binary_search(s, target, (mid + 1), high);
    }
}

// Linear search
fn linear_search(s: slice(i32), target: i32, length: i32) -> i32 {
    let i: i32 = 0;
    while (i < length) {
        if (at(s, cast(usize, i)) == target) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

// Find minimum value in a slice
fn find_min(s: slice(i32), length: i32) -> i32 {
    let min_val: i32 = at(s, cast(usize, 0));
    let i: i32 = 1;
    while (i < length) {
        let val: i32 = at(s, cast(usize, i));
        if (val < min_val) {
            min_val = val;
        }
        i = (i + 1);
    }
    return min_val;
}

// Find maximum value in a slice
fn find_max(s: slice(i32), length: i32) -> i32 {
    let max_val: i32 = at(s, cast(usize, 0));
    let i: i32 = 1;
    while (i < length) {
        let val: i32 = at(s, cast(usize, i));
        if (val > max_val) {
            max_val = val;
        }
        i = (i + 1);
    }
    return max_val;
}

// Sum all elements
fn sum_slice(s: slice(i32), length: i32) -> i32 {
    let total: i32 = 0;
    let i: i32 = 0;
    while (i < length) {
        total = (total + at(s, cast(usize, i)));
        i = (i + 1);
    }
    return total;
}

// Count elements matching a predicate value
fn count_equal(s: slice(i32), length: i32, target: i32) -> i32 {
    let count: i32 = 0;
    let i: i32 = 0;
    while (i < length) {
        if (at(s, cast(usize, i)) == target) {
            count = (count + 1);
        }
        i = (i + 1);
    }
    return count;
}

// Check if slice is sorted (ascending)
fn is_sorted(s: slice(i32), length: i32) -> bool {
    if (length <= 1) {
        return true;
    }

    let i: i32 = 1;
    while (i < length) {
        let prev: i32 = at(s, cast(usize, (i - 1)));
        let curr: i32 = at(s, cast(usize, i));
        if (prev > curr) {
            return false;
        }
        i = (i + 1);
    }
    return true;
}

// Greatest common divisor using Euclidean algorithm
fn gcd(a: i32, b: i32) -> i32 {
    while (b != 0) {
        let temp: i32 = b;
        b = (a % b);
        a = temp;
    }
    return a;
}

// Least common multiple
fn lcm(a: i32, b: i32) -> i32 {
    return ((a / gcd(a, b)) * b);
}

// Fast integer power (exponentiation by squaring)
fn pow(base: i32, exp: i32) -> i32 {
    if (exp == 0) {
        return 1;
    }
    if (exp == 1) {
        return base;
    }

    let result: i32 = 1;
    let b: i32 = base;
    let e: i32 = exp;

    while (e > 0) {
        if (((e % 2)) == 1) {
            result = (result * b);
        }
        b = (b * b);
        e = (e / 2);
    }
    return result;
}

fn main() -> i32 {
    // Test GCD and LCM
    let g: i32 = gcd(48, 18);  // Should be 6
    let l: i32 = lcm(4, 6);    // Should be 12

    // Test power
    let p: i32 = pow(2, 10);   // Should be 1024

    discard(g);
    discard(l);

    return p;
}
